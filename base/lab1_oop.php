<?php
//OOP
class Human{
    var $name;
    var $age;

    function __construct($nameofperson, $ageofperson){
        $this->name = $nameofperson;
        $this->age = $ageofperson;
    }

    function set_name($newname)
    {
        $this->name = $newname;
    }

    function set_age($newage)
    {
        $this->age = $newage;
    }

    function get_name()
    {
        return $this->name;
    }

    function get_age()
    {
        return $this->age;
    }
}
$firstObject =  new Human("Joseph", 23);
$secondObject=  new Human("Taylor", 35);

echo $firstObject->get_name().' ' . $firstObject->get_age();
echo "<br><br>";

//inheritance
class User
{
    private $name, $age;

    function __constructWithoutParameters()
    {
        echo "Constructor without parameters";
    }

    function __construct($name, $age)
    {
        $this->name = $name;
        $this->age = $age;
    }

    function getClassInfo()
    {
        echo "Класс User описывает пользователей<br>";
    }

    function getInfo()
    {
        echo "Имя: $this->name; Возраст: $this->age<br>";
    }

    final function someInform()
    {
        echo "Эту функцию нельзя переопределять в классе-наследнике<br>";
    }

    function __destruct()
    {
        echo "Уничтожается " . __CLASS__  . "<br>";
    }
}

class Customer extends User
{
    private $account, $sum;

    function __constructWithoutParameters(){
        parent::__constructWithoutParameters();
    }

    function __construct($name, $age, $acc)
    {
        // вызов конструктора базового класс
        parent::__construct($name, $age);
        $this->account=$acc;
        $this->sum=20;
    }

    // скрывает родительский метод getClassInfo()
    function getClassInfo()
    {
        echo "Класс Customer описывает клиентов<br>";
    }

    function getInfo()
    {
        parent::getInfo();
        echo "Номер счета $this->account; Сумма: $this->sum <br>";
    }

    //function someInform(){}
    function __destruct()
    {
        parent::__destruct(); // TODO: Change the autogenerated stub
    }

}

$client = new Customer("Джон", 25, "1123400895");
$client->getClassInfo();
$client->getInfo();
echo "<br><br>";

//using interface
interface Persistable {
    public function save();
    public function load();
    public function delete();
}

class Member implements Persistable {
    private $username;
    private $location;
    private $homepage;
    public function __construct( $username, $location, $homepage ) {
        $this->username = $username;
        $this->location = $location;
        $this->homepage = $homepage;
    }
    public function getUsername() {
        return $this->username;
    }
    public function getLocation() {
        return $this->location;
    }
    public function getHomepage() {
        return $this->homepage;
    }
    public function save() {
        echo "Saving member to database<br>";
    }
    public function load() {
        echo "Loading member from database<br>";
    }
    public function delete () {
        echo "Deleting member from database<br>";
    }
}

$member = new Member("Andrey", "Ukraine", 12346);
$member->save();
$member->load();
$member->delete();

echo '<br>';

//Синглтон
class Singleton
{
    /**
     * Объект одиночки храниться в статичном поле класса. Это поле — массив, так
     * как мы позволим нашему Одиночке иметь подклассы. Все элементы этого
     * массива будут экземплярами кокретных подклассов Одиночки.
     */
    private static $instances = [];

    /**
     * Конструктор Одиночки всегда должен быть скрытым, чтобы предотвратить
     * создание объекта через оператор new.
     */
    private function __construct() { }

    /**
     * Одиночки не должны быть клонируемыми.
     */
    private function __clone() { }

    /**
     * Одиночки не должны быть восстанавливаемыми из строк.
     */
    public function __wakeup()
    {
        throw new \Exception("Cannot unserialize a singleton.");
    }

    /**
     * Это статический метод, управляющий доступом к экземпляру одиночки. При
     * первом запуске, он создаёт экземпляр одиночки и помещает его в
     * статическое поле. При последующих запусках, он возвращает клиенту объект,
     * хранящийся в статическом поле.
     *
     * Эта реализация позволяет вам расширять класс Одиночки, сохраняя повсюду
     * только один экземпляр каждого подкласса.
     */
    public static function getInstance(): Singleton
    {
        $cls = static::class;
        if (!isset(self::$instances[$cls])) {
            self::$instances[$cls] = new static;
        }

        return self::$instances[$cls];
    }

    public function someBusinessLogic()
    {
        // ...
    }
}

/**
 * Клиентский код.
 */
function clientCode()
{
    $s1 = Singleton::getInstance();
    $s2 = Singleton::getInstance();
    if ($s1 === $s2) {
        echo "Singleton works, both variables contain the same instance.<br>";
    } else {
        echo "Singleton failed, variables contain different instances.<br>";
    }
}

clientCode();